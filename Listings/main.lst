C51 COMPILER V9.60.0.0   MAIN                                                              12/14/2023 21:13:54 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\WorkSoftware\Keil5_C51\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\code) DEBUG OBJE
                    -CTEXTEND PRINT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          /*
   2          program versions : 3.1.1
   3          
   4          此分支[branch2]用于编写校验代码
   5          
   6          Descrription: 新增了分支"branch1用于修改测量功能的代码"
   7          
   8          updata record:
   9          修改了检测功能的代码，测量22nf时不再显示22333pF(单位换算)
  10          新增了校验的功能代码以及校验页面
  11          
  12          modification: 2023/12/14 16:00
  13          
  14          modifier: Cameron Bright
  15          
  16          */
  17          
  18          #include "main.h"
  19          #include <string.h>
  20          #include "LCD1602.h"  //包含LCD1602头文件
  21          #include "Key.h"      //按键扫描函数
  22          #include "ADC.h"
  23          #include "Relay.h"    //继电器头文件
  24          #include <stdio.h>
  25          
  26          sbit Buzzer = P2^3;//蜂鸣器 低电平工作
  27          
  28          void Timer0_Init(void); //1毫秒@11.0592MHz
  29          void Delay(unsigned int delay); //定时器延时 
  30          
  31          void Key_Proc(void);       //Keystroke process function
  32          void Lcd_Proc(void);       //LCD Dsiplay process function
  33          void Detection_Proc(void); //cap detection process function
  34          
  35          unsigned int key_slow_down = 0; //按键刷新计数
  36          unsigned int lcd_slow_down = 0; //LCD刷新计数
  37          unsigned int Det_slow_down = 0; //adc检测刷新计数
  38          
  39          unsigned int timer_tick = 0;
  40          unsigned int buzzer_tick = 0;//用于开机计数500ms
  41          
  42          unsigned char key_value; //按键处理变量
  43          unsigned char key_down;  //按键下降沿
  44          unsigned char key_up;    //上升沿
  45          unsigned char key_old;   //上次的按键值
  46          
  47          unsigned int led1_tick = 1; //状态灯计数
  48          unsigned int key_tick; //long key press count
  49          unsigned int delay_tick;//定时器延时计数
  50          unsigned int cap_tick;  //电容测量计计时
  51          unsigned int relay_tick = 0;//继电器计时
  52          
  53          unsigned char dispbuf[6] = {'0','0','0','0','0','0'};
  54          unsigned char page = 0;//lcd 显示界面
C51 COMPILER V9.60.0.0   MAIN                                                              12/14/2023 21:13:54 PAGE 2   

  55          unsigned char cursor = 5; //光标
  56          
  57          unsigned char relay_index;  //继电器选择
  58          
  59          unsigned char password[6] = {'0','0','0','0','0','0'};
  60          //unsigned char password_true[6] = {'8','7','6','5','4','3'};
  61          
  62          unsigned char password_true[6] = {'1','0','0','0','0','0'}; //正确密码
  63          //unsigned char password_true[6] = {'8','7','6','5','4','3'}; //正确密码
  64          unsigned char password_for = 0; //index
  65          
  66          unsigned char adc_char;     //adc检测返回的char类型值
  67          float adc_float;            //adc检测返回的float类型值，就是具体的电压值
  68          
  69          xdata float cap_value_k1 = 0;         
  70          xdata float cap_value_k2 = 0;
  71          xdata float cap_value_k3 = 0;
  72          xdata float cap_value_k4 = 0;
  73          
  74          xdata float cap_calibrations_value[9];
  75          xdata float cap_calibrations_buf = 0; //测量校验值的缓冲区
  76          xdata float increments[] = {100, 10, 1, 0, 0.1, 0.01};
  77          
  78          unsigned char calibrations = 0; //校准
  79          
  80          float cap_value;            //存放电容的容值
  81          char cap_units;             //电容的单位0:uF、1:nF、 2:pF
  82          
  83          void main()
  84          {
  85   1        Timer0_Init();//定时器初始化
  86   1        LCD_Init(); //LCD函数初始化
  87   1        ADC_Init(); //ADC函数初始化
  88   1        
  89   1        //Buzzer = 0;//蜂鸣器初始化
  90   1        
  91   1        Relay_Control(0, 0);//继电器全关
  92   1        
  93   1        while(1)
  94   1        { 
  95   2          Key_Proc();
  96   2          Lcd_Proc();
  97   2          Detection_Proc(); 
  98   2        }
  99   1      }
 100          
 101          //================LCD=======================
 102          
 103          void Lcd_Proc(void)     //LCD Dsiplay process function
 104          {
 105   1        if(lcd_slow_down) return;   //200ms刷新一次
 106   1          lcd_slow_down = 1;
 107   1        
 108   1        if(page == 0)            //测量界面 初始界面
 109   1        { 
 110   2          sprintf((char *)dispbuf,"%06.2f",cap_value);
 111   2          
 112   2          LCD_WriteCommand(0x0C);//关光标
 113   2          
 114   2          LCD_ShowString(1,1,"Press OK Start!");
 115   2          
 116   2          LCD_ShowChar(2,1,dispbuf[0]);
C51 COMPILER V9.60.0.0   MAIN                                                              12/14/2023 21:13:54 PAGE 3   

 117   2          LCD_ShowChar(2,2,dispbuf[1]);
 118   2          LCD_ShowChar(2,3,dispbuf[2]);
 119   2          LCD_ShowChar(2,4,dispbuf[3]);
 120   2          LCD_ShowChar(2,5,dispbuf[4]);
 121   2          LCD_ShowChar(2,6,dispbuf[5]);
 122   2          
 123   2          switch(cap_units)
 124   2          {
 125   3            case 0:
 126   3              LCD_ShowString(2,7,"uF");
 127   3              break;
 128   3            case 1:
 129   3              LCD_ShowString(2,7,"nF");
 130   3              break;
 131   3            case 2:
 132   3              LCD_ShowString(2,7,"pF");
 133   3              break;
 134   3            default:
 135   3              break;
 136   3          }
 137   2          
 138   2          //LCD_ShowNum(2,8,key_tick,4); //测试按键长按
 139   2        }
 140   1        else if(page == 1)       //输密码页
 141   1        {
 142   2          LCD_WriteCommand(0x0f);//开光标
 143   2          
 144   2          LCD_ShowString(1,2,"Input Password");
 145   2          LCD_ShowString(2,6,password);
 146   2        }
 147   1        else if(page == 2)       //密码错误页
 148   1        {
 149   2          LCD_WriteCommand(0x0C);//关光标
 150   2          LCD_ShowString(1,6,"ERROR");
 151   2        }
 152   1        else if(page == 3)       //密码正确页
 153   1        {
 154   2          LCD_WriteCommand(0x0C);//关光标
 155   2          LCD_ShowString(1,6,"RIGHT");
 156   2        }
 157   1        else if(page == 4)
 158   1        {
 159   2          LCD_ShowString(1,1,"Wait...");
 160   2          LCD_ShowString(2,1,"Press OK End");
 161   2        }
 162   1        else if(page == 5)       //校准输入页
 163   1        {
 164   2          LCD_WriteCommand(0x0f);//开光标
 165   2          sprintf((char *)dispbuf,"%06.2f",cap_calibrations_buf);
 166   2          
 167   2          LCD_ShowChar(2,1,dispbuf[0]);
 168   2          LCD_ShowChar(2,2,dispbuf[1]);
 169   2          LCD_ShowChar(2,3,dispbuf[2]);
 170   2          LCD_ShowChar(2,4,dispbuf[3]);
 171   2          LCD_ShowChar(2,5,dispbuf[4]);
 172   2          LCD_ShowChar(2,6,dispbuf[5]);
 173   2          
 174   2          LCD_ShowChar(1,1,calibrations+0x30); //左上角显示校准挡位 +0x30转换成ASC11码输出
 175   2        }
 176   1        else if(page == 6) //校准完成页
 177   1        {
 178   2          LCD_ShowChar(1,1,'A');
C51 COMPILER V9.60.0.0   MAIN                                                              12/14/2023 21:13:54 PAGE 4   

 179   2          Delay(2000);
 180   2          Lcd_Clear();
 181   2          page = 0;
 182   2        }
 183   1        
 184   1        if(page == 2 || page == 3) //闪一下ERROR和RIGHT的页面
 185   1        {
 186   2          Delay(2000); //两秒后切换页面
 187   2          Lcd_Clear();
 188   2          page = 5;//密码输完后切换到校准页面   
 189   2        }
 190   1        
 191   1        //LCD_WriteCommand(0x80+cursor); //第一行光标
 192   1        LCD_WriteCommand(0xc0+cursor); //第二行光标 
 193   1      }
 194          
 195          //================Key=======================
 196          
 197          void Key_Proc(void)
 198          {
 199   1        if(key_slow_down) return;   //10ms更新一次
 200   1          key_slow_down = 1;
 201   1        
 202   1        key_value = Key_Read();
 203   1        key_down = key_value & (key_value ^ key_old);
 204   1        key_up = ~key_value & (key_value ^ key_old);
 205   1        key_old = key_value;
 206   1      
 207   1        if(key_down)       //长按五秒
 208   1          key_tick = 2000;
 209   1        
 210   1        if(key_old)
 211   1        {
 212   2          if(key_tick == 0)
 213   2            {
 214   3              Lcd_Clear();
 215   3              page = 1;
 216   3              
 217   3              //清空密码字符串
 218   3              for(password_for = 0;password_for <= 5; password_for++)
 219   3              {
 220   4                password[password_for] = '0';
 221   4              }
 222   3            }
 223   2        }
 224   1        
 225   1        if(key_tick)
 226   1        {
 227   2          switch(key_up)
 228   2          {
 229   3            case 1:        //背光/校准按键
 230   3            {
 231   4              key_tick = 0;
 232   4              break;
 233   4            }
 234   3            case 2:        //↑ 
 235   3            {
 236   4              if(page == 1)   //输密码页
 237   4              {
 238   5                password[cursor-5] += 1;  //按照光标位置加
 239   5                if(password[cursor-5] > '9')
 240   5                  password[cursor-5] = '9';
C51 COMPILER V9.60.0.0   MAIN                                                              12/14/2023 21:13:54 PAGE 5   

 241   5              }
 242   4              else if(page == 5) //校准页
 243   4              {
 244   5                cap_calibrations_buf += increments[cursor];
 245   5                if(cap_calibrations_buf >= 1000)
 246   5                  cap_calibrations_buf -= 1000;
 247   5              }
 248   4              key_tick = 0;
 249   4              break;
 250   4            }
 251   3            case 3:        //↓
 252   3            {
 253   4              if(page == 1)   //输密码页
 254   4              {
 255   5                password[cursor-5] -= 1; //按照光标位置减
 256   5                if(password[cursor-5] == '/')
 257   5                  password[cursor-5] = '0';
 258   5              }else if(page == 5) //校准页
 259   4              {
 260   5                cap_calibrations_buf -= increments[cursor];
 261   5                if(cap_calibrations_buf < 0)
 262   5                  cap_calibrations_buf = 0;
 263   5              }
 264   4              key_tick = 0;
 265   4              break;
 266   4            }
 267   3            case 4:        //←
 268   3            {
 269   4              if(page == 1)   //输密码页
 270   4              {
 271   5                if(--cursor <= 5)
 272   5                  cursor = 5;
 273   5              }else if(page == 5) //校准页
 274   4              {
 275   5                if(--cursor == 255) //光标限位unsigned char类型0-1=255
 276   5                  cursor = 0;
 277   5              }
 278   4              key_tick = 0;
 279   4              break;
 280   4            }
 281   3            case 5:        //→
 282   3            {
 283   4              if(page == 1)  //输密码页
 284   4              {
 285   5                if(++cursor >= 10)
 286   5                  cursor = 10;
 287   5              }else if(page == 5) //校准页
 288   4              {
 289   5                if(++cursor > 5)  //光标限位
 290   5                  cursor = 5;
 291   5              }
 292   4              key_tick = 0;
 293   4              break;
 294   4            }
 295   3            case 6:        //OK
 296   3            {
 297   4              if(page == 0)      //如果在测量页，按下OK键开始测量
 298   4              {
 299   5                Lcd_Clear();
 300   5                page = 4;
 301   5              }
 302   4              else if(page == 4) //如果正在测量，按下OK键停止测量
C51 COMPILER V9.60.0.0   MAIN                                                              12/14/2023 21:13:54 PAGE 6   

 303   4              {
 304   5                Lcd_Clear();
 305   5                page = 0;
 306   5                cap_value = 0;//清零
 307   5                
 308   5                if(cap_value_k1 > 5.00)//如果被测电容超过了量程(50uF - 220pF)，就限制在50uF
 309   5                {
 310   6                  cap_value = 50.0;
 311   6                  cap_units = 0;           //单位换成uF
 312   6                }
 313   5                if(cap_value_k1 <= 5.00 && cap_value_k1 > 0.50)    //测量50uF-5uF
 314   5                {
 315   6                  cap_value = cap_value_k1 * 10;
 316   6                  cap_units = 0;           //单位换成uF
 317   6                }
 318   5                else if(cap_value_k1 <= 0.50 && cap_value_k2 > 0.50)//测量5uF-500nF
 319   5                {
 320   6                  cap_value = cap_value_k2;
 321   6                  cap_units = 0;           //单位换成uF
 322   6                }
 323   5                else if(cap_value_k2 <= 0.50 && cap_value_k3 > 0.50)//测量500nF-5nF
 324   5                {
 325   6                  cap_value = cap_value_k3 * 100;
 326   6                  cap_units = 1;           //单位换成nF
 327   6                }
 328   5                else if(cap_value_k3 <= 0.50 && cap_value_k4 > 0.00)//测量5000pF-0pF
 329   5                {
 330   6                  cap_value = cap_value_k4 * 10000;
 331   6                  if(cap_value >= 10000)
 332   6                  {
 333   7                    cap_value = cap_value / 1000.0;
 334   7                    cap_units = 1;           //单位换成nF
 335   7                  }
 336   6                  else 
 337   6                    cap_units = 2;           //单位换成pF
 338   6                }
 339   5            
 340   5              }
 341   4              else if(page == 1) //如果在输密码页，按下OK键确认密码
 342   4              {
 343   5                Lcd_Clear();
 344   5                if(strncmp(password,password_true,6) == 0)
 345   5                  page = 3;
 346   5                else
 347   5                  page = 2;
 348   5              }
 349   4              else if(page == 5) //如果在校验页面
 350   4              { 
 351   5                cap_calibrations_value[calibrations] = cap_calibrations_buf;//将每一次的校验值储存起来
 352   5                cap_calibrations_buf = 0;//缓冲区清零
 353   5                calibrations += 1;
 354   5                if(calibrations >= 10)
 355   5                {
 356   6                  calibrations = 0;
 357   6                  page = 6; //跳转到校准完成页
 358   6                }
 359   5              }   
 360   4              
 361   4              key_tick = 0;
 362   4              break;
 363   4            }
 364   3            
C51 COMPILER V9.60.0.0   MAIN                                                              12/14/2023 21:13:54 PAGE 7   

 365   3            default:
 366   3              break;
 367   3          }   
 368   2        }
 369   1      }
 370          
 371          //================电容检测函数======================
 372          void Detection_Proc(void)
 373          {
 374   1        if(Det_slow_down) return;   //10ms更新一次
 375   1        Det_slow_down = 1;
 376   1        
 377   1        if(relay_index == 1)
 378   1        {
 379   2          adc_char = GetADCResult(0); //测量P10 ADC
 380   2          cap_value_k1 = (float)adc_char/51;//转换成电压值
 381   2        }
 382   1        else if(relay_index == 2)
 383   1        {
 384   2          adc_char = GetADCResult(0); //测量P10 ADC
 385   2          cap_value_k2 = (float)adc_char/51;//转换成电压值
 386   2        }
 387   1        else if(relay_index == 3)
 388   1        {
 389   2          adc_char = GetADCResult(0); //测量P10 ADC
 390   2          cap_value_k3 = (float)adc_char/51;//转换成电压值
 391   2        }
 392   1        else if(relay_index == 4)
 393   1        {
 394   2          adc_char = GetADCResult(0); //测量P10 ADC
 395   2          cap_value_k4 = (float)adc_char/51;//转换成电压值
 396   2        }
 397   1      }
 398          
 399          //================中断函数=======================
 400          void Timer0_Isr(void) interrupt 1
 401          {
 402   1        if(++key_slow_down == 10) key_slow_down = 0;
 403   1        if(++lcd_slow_down == 200) lcd_slow_down = 0;
 404   1        if(++Det_slow_down == 10) Det_slow_down = 0;
 405   1        
 406   1        if(delay_tick > 0) delay_tick--;//延时函数 会卡住当前函数
 407   1        if(key_tick > 0) key_tick--;    //按键计时
 408   1        
 409   1        //呼吸灯 用于测试中断
 410   1      //  if(++led1_tick >= 1000)
 411   1      //  {
 412   1      //    LED1 ^= 1;
 413   1      //    led1_tick = 0;
 414   1      //  }
 415   1          
 416   1        
 417   1      //  if(Buzzer == 0)
 418   1      //  {
 419   1      //    if(++buzzer_tick >= 500)
 420   1      //      {
 421   1      //        Buzzer = 1;
 422   1      //        buzzer_tick = 0;
 423   1      //      }
 424   1      //  }   
 425   1      
 426   1      //---------继电器切换控制----------------------
C51 COMPILER V9.60.0.0   MAIN                                                              12/14/2023 21:13:54 PAGE 8   

 427   1        if(page ==  4)
 428   1        {
 429   2          if(++relay_tick > 1000)
 430   2          {
 431   3            if(++relay_index > 4)
 432   3              relay_index = 1;
 433   3            relay_tick = 0;
 434   3          }
 435   2          
 436   2          Relay_Control(relay_index, 1);
 437   2        }   
 438   1          
 439   1        
 440   1      }
 441          
 442          void Delay(unsigned int delay) //定时器延时 会卡住当前函数
 443          {
 444   1        delay_tick = delay;
 445   1        while(delay_tick > 0);
 446   1      }
 447          
 448          void Timer0_Init(void)    //1毫秒@11.0592MHz
 449          {
 450   1        AUXR |= 0x80;     //定时器时钟1T模式
 451   1        TMOD &= 0xF0;     //设置定时器模式
 452   1        TL0 = 0xCD;       //设置定时初始值
 453   1        TH0 = 0xD4;       //设置定时初始值
 454   1        TF0 = 0;        //清除TF0标志
 455   1        TR0 = 1;        //定时器0开始计时
 456   1        ET0 = 1;        //使能定时器0中断
 457   1        EA = 1;         //总中断
 458   1      }
 459           


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1958    ----
   CONSTANT SIZE    =     80    ----
   XDATA SIZE       =     80    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     57    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
