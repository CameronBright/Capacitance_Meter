C51 COMPILER V9.60.0.0   MAIN                                                              11/18/2023 21:38:25 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\WorkSoftware\Keil5_C51\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\code) DEBUG OBJE
                    -CTEXTEND PRINT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          /*
   2          program versions : 3.2.1
   3          
   4          已经能检测电容，但是校验还没有写
   5          
   6          modification: 2023/11/18 19:47
   7          
   8          modifier: Cameron Bright
   9          
  10          */
  11          
  12          #include "main.h"
  13          #include <string.h>
  14          #include "LCD1602.h"  //包含LCD1602头文件
  15          #include "Key.h"      //按键扫描函数
  16          #include "ADC.h"
  17          #include <stdio.h>
  18          
  19          sbit V0 = P1^2;
  20          
  21          sbit K1 = P3^7;//继电器 低电平闭合
  22          sbit K2 = P3^6;
  23          sbit K3 = P3^5;
  24          sbit K4 = P3^4;
  25          
  26          sbit Buzzer = P2^3;//蜂鸣器 低电平工作
  27          
  28          void Timer0_Init(void); //1毫秒@11.0592MHz
  29          void Delay(unsigned int delay); //定时器延时 
  30          
  31          void Key_Proc(void);       //Keystroke process function
  32          void Lcd_Proc(void);       //LCD Dsiplay process function
  33          void Detection_Proc(void); //cap detection process function
  34          
  35          unsigned int key_slow_down = 0; //按键刷新计数
  36          unsigned int lcd_slow_down = 0; //LCD刷新计数
  37          unsigned int Det_slow_down = 0; //adc检测刷新计数
  38          
  39          unsigned int timer_tick = 0;
  40          unsigned int buzzer_tick = 0;//用于开机计数500ms
  41          
  42          unsigned char key_value; //按键处理变量
  43          unsigned char key_down;  //按键下降沿
  44          unsigned char key_up;    //上升沿
  45          unsigned char key_old;   //上次的按键值
  46          
  47          unsigned int led1_tick = 1; //状态灯计数
  48          unsigned int key_tick; //long key press count
  49          unsigned int delay_tick;//定时器延时计数
  50          unsigned int cap_tick;  //电容测量计计时
  51          
  52          unsigned char dispbuf[4] = {'0','0','0','0'};
  53          unsigned char page = 0;//lcd 显示界面
  54          unsigned char cursor = 5; //光标
C51 COMPILER V9.60.0.0   MAIN                                                              11/18/2023 21:38:25 PAGE 2   

  55          
  56          
  57          
  58          unsigned char password[6] = {'0','0','0','0','0','0'};
  59          //unsigned char password_true[6] = {'8','7','6','5','4','3'};
  60          
  61          unsigned char password_true[6] = {'1','0','0','0','0','0'}; //正确密码
  62          //unsigned char password_true[6] = {'8','7','6','5','4','3'}; //正确密码
  63          unsigned char password_for = 0; //index
  64          
  65          unsigned char adc_char;     //adc检测返回的char类型值
  66          float adc_float;            //adc检测返回的float类型值，就是具体的电压值
  67          float cap_value;            //存放电容的容值
  68          char cap_units[2];    //电容的单位
  69          
  70          void main()
  71          {
  72   1        Timer0_Init();//定时器初始化
  73   1        LCD_Init(); //LCD函数初始化
  74   1        ADC_Init(); //ADC函数初始化
  75   1        
  76   1        //Buzzer = 0;//蜂鸣器初始化
  77   1        
  78   1        K1 = 1;
  79   1        K2 = 1;
  80   1        K3 = 1;
  81   1        K4 = 1;
  82   1        
  83   1        while(1)
  84   1        { 
  85   2          Key_Proc();
  86   2          Lcd_Proc();
  87   2          Detection_Proc();
  88   2        }
  89   1        
  90   1      }
  91          
  92          //================LCD=======================
  93          
  94          void Lcd_Proc(void)     //LCD Dsiplay process function
  95          {
  96   1        if(lcd_slow_down) return;   //200ms刷新一次
  97   1          lcd_slow_down = 1;
  98   1        
  99   1        if(page == 0)            //测量界面 初始界面
 100   1        { 
 101   2          sprintf((char *)dispbuf,"%3.2f",cap_value);
 102   2          
 103   2          LCD_WriteCommand(0x0C);//关光标
 104   2          
 105   2          LCD_ShowString(1,1,"Press OK Start!");
 106   2          
 107   2          LCD_ShowChar(2,1,dispbuf[0]);
 108   2          LCD_ShowChar(2,2,dispbuf[1]);
 109   2          LCD_ShowChar(2,3,dispbuf[2]);
 110   2          LCD_ShowChar(2,4,dispbuf[3]);
 111   2          
 112   2          //LCD_ShowNum(2,8,key_tick,4); //测试按键长按
 113   2        }
 114   1        else if(page == 1)       //输密码页
 115   1        {
 116   2          LCD_WriteCommand(0x0f);//开光标
C51 COMPILER V9.60.0.0   MAIN                                                              11/18/2023 21:38:25 PAGE 3   

 117   2          
 118   2          LCD_ShowString(1,2,"Input Password");
 119   2          LCD_ShowString(2,6,password);
 120   2        }
 121   1        else if(page == 2)       //密码错误页
 122   1        {
 123   2          LCD_WriteCommand(0x0C);//关光标
 124   2          LCD_ShowString(1,6,"ERROR");
 125   2        }
 126   1        else if(page == 3)       //密码正确页
 127   1        {
 128   2          LCD_WriteCommand(0x0C);//关光标
 129   2          LCD_ShowString(1,6,"RIGHT");
 130   2        }
 131   1        else if(page == 4)
 132   1        {
 133   2          LCD_ShowString(1,1,"Wait...");
 134   2          LCD_ShowString(2,1,"Press OK End");
 135   2        }
 136   1        
 137   1        if(page == 2 || page == 3) //闪一下ERROR和RIGHT的页面
 138   1        {
 139   2          Delay(2000); //两秒后切换页面
 140   2          Lcd_Clear();
 141   2          page = 0;//密码输完后切换到校准页面   
 142   2        }
 143   1        
 144   1        //LCD_WriteCommand(0x80+cursor); //第一行光标
 145   1        LCD_WriteCommand(0xc0+cursor); //第二行光标 
 146   1      }
 147          
 148          //================Key=======================
 149          
 150          void Key_Proc(void)
 151          {
 152   1        if(key_slow_down) return;   //10ms更新一次
 153   1          key_slow_down = 1;
 154   1        
 155   1        key_value = Key_Read();
 156   1        key_down = key_value & (key_value ^ key_old);
 157   1        key_up = ~key_value & (key_value ^ key_old);
 158   1        key_old = key_value;
 159   1      
 160   1        if(key_down)       //长按五秒
 161   1          key_tick = 2000;
 162   1        
 163   1        if(key_old)
 164   1        {
 165   2          if(key_tick == 0)
 166   2            {
 167   3              Lcd_Clear();
 168   3              page = 1;
 169   3              
 170   3              //清空密码字符串
 171   3              for(password_for = 0;password_for <= 5; password_for++)
 172   3              {
 173   4                password[password_for] = '0';
 174   4              }
 175   3            }
 176   2        }
 177   1        
 178   1        if(key_tick)
C51 COMPILER V9.60.0.0   MAIN                                                              11/18/2023 21:38:25 PAGE 4   

 179   1        {
 180   2          switch(key_up)
 181   2          {
 182   3            case 1:        //背光/校准按键
 183   3            {
 184   4              key_tick = 0;
 185   4              break;
 186   4            }
 187   3            case 2:        //↑ 
 188   3            {
 189   4              password[cursor-5] += 1;
 190   4              if(password[cursor-5] > '9')
 191   4                password[cursor-5] = '9';
 192   4            
 193   4              key_tick = 0;
 194   4              break;
 195   4            }
 196   3            case 3:        //↓
 197   3            {
 198   4              password[cursor-5] -= 1;
 199   4              if(password[cursor-5] == '/')
 200   4                password[cursor-5] = '0';
 201   4              
 202   4              key_tick = 0;
 203   4              break;
 204   4            }
 205   3            case 4:        //←
 206   3            {
 207   4              if(--cursor <= 5)
 208   4                cursor = 5;
 209   4              key_tick = 0;
 210   4              break;
 211   4            }
 212   3            case 5:        //→
 213   3            {
 214   4              if(++cursor >= 10)
 215   4                cursor = 10;
 216   4              key_tick = 0;
 217   4              break;
 218   4            }
 219   3            case 6:        //OK
 220   3            {
 221   4              if(page == 0)      //如果在测量页，按下OK键开始测量
 222   4              {
 223   5                Lcd_Clear();
 224   5                page = 4;
 225   5                K1 = 0;
 226   5              }
 227   4              else if(page == 4) //如果正在测量，按下OK键停止测量
 228   4              {
 229   5                Lcd_Clear();
 230   5                page = 0;
 231   5              }
 232   4              else if(page == 1) //如果在输密码页，按下OK键确认密码
 233   4              {
 234   5                Lcd_Clear();
 235   5                if(strncmp(password,password_true,6) == 0)
 236   5                  page = 3;
 237   5                else
 238   5                  page = 2;
 239   5              }
 240   4              
C51 COMPILER V9.60.0.0   MAIN                                                              11/18/2023 21:38:25 PAGE 5   

 241   4              key_tick = 0;
 242   4              break;
 243   4            }
 244   3            
 245   3            default:
 246   3              break;
 247   3          }   
 248   2        }
 249   1        
 250   1      }
 251          
 252          void Detection_Proc(void)
 253          {
 254   1        if(Det_slow_down) return;   //10ms更新一次
 255   1        Det_slow_down = 1;
 256   1        
 257   1        if(page == 4)
 258   1        {
 259   2          Delay(100);
 260   2          adc_char = GetADCResult(0); //测量P10 ADC
 261   2          adc_float = (float)adc_char/51;//转换成电压值
 262   2          
 263   2          if((char)adc_float > 0)
 264   2          {
 265   3            cap_value = adc_float;
 266   3            sprintf(cap_units,"uF");
 267   3            //K1 = 1;
 268   3          }
 269   2            
 270   2        }
 271   1          
 272   1        
 273   1      }
 274          
 275          //================中断函数=======================
 276          void Timer0_Isr(void) interrupt 1
 277          {
 278   1        if(++key_slow_down == 10) key_slow_down = 0;
 279   1        if(++lcd_slow_down == 200) lcd_slow_down = 0;
 280   1        if(++Det_slow_down == 10) Det_slow_down = 0;
 281   1        
 282   1        if(delay_tick > 0) delay_tick--;//延时函数 会卡住当前函数
 283   1        if(key_tick > 0) key_tick--;    //按键计时
 284   1        
 285   1        //呼吸灯 用于测试中断
 286   1      //  if(++led1_tick >= 1000)
 287   1      //  {
 288   1      //    LED1 ^= 1;
 289   1      //    led1_tick = 0;
 290   1      //  }
 291   1          
 292   1        
 293   1      //  if(Buzzer == 0)
 294   1      //  {
 295   1      //    if(++buzzer_tick >= 500)
 296   1      //      {
 297   1      //        Buzzer = 1;
 298   1      //        buzzer_tick = 0;
 299   1      //      }
 300   1      //  }   
 301   1      }
 302          
C51 COMPILER V9.60.0.0   MAIN                                                              11/18/2023 21:38:25 PAGE 6   

 303          void Delay(unsigned int delay) //定时器延时 会卡住当前函数
 304          {
 305   1        delay_tick = delay;
 306   1        while(delay_tick > 0);
 307   1      }
 308          
 309          void Timer0_Init(void)    //1毫秒@11.0592MHz
 310          {
 311   1        AUXR |= 0x80;     //定时器时钟1T模式
 312   1        TMOD &= 0xF0;     //设置定时器模式
 313   1        TL0 = 0xCD;       //设置定时初始值
 314   1        TH0 = 0xD4;       //设置定时初始值
 315   1        TF0 = 0;        //清除TF0标志
 316   1        TR0 = 1;        //定时器0开始计时
 317   1        ET0 = 1;        //使能定时器0中断
 318   1        EA = 1;         //总中断
 319   1      }
 320           


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    791    ----
   CONSTANT SIZE    =     73    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     52    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
